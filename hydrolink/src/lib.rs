use std::{
    fmt::{self, Display, Formatter},
    result,
    sync::{Arc, Mutex, RwLock},
};

use async_trait::async_trait;
use reqwest::{
    header::{HeaderMap, InvalidHeaderValue},
    Client,
};

mod rest;
pub use rest::*;

mod websocket;
use tokio::{net::TcpStream, select, spawn, sync::oneshot};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{
        self,
        http::{self, Request},
    },
    MaybeTlsStream, WebSocketStream,
};
pub use websocket::*;

mod internal;
use internal::*;

/// Event handler used by the Websocket message parser.
#[async_trait]
pub trait Handler {
    /// Triggered when the Websocket connection is established and a session ID for the REST client is received.
    async fn ready(&self, _lavalink: Lavalink, _resumed: bool) {}
    /// Triggered when the Websocket disconnects from the Lavalink server, this event actually triggers as soon as the message parser loop is finished.
    async fn disconnect(&self, _lavalink: Lavalink) {}
    /// Event triggered when a new track is started.
    async fn track_start_event(&self, _lavalink: Lavalink, _message: LavalinkTrackStartEvent) {}
    /// Event triggered when a track ends.
    async fn track_end_event(&self, _lavalink: Lavalink, _message: LavalinkTrackEndEvent) {}
}

/// Enum that groups all the errors that can occur.
#[derive(Debug)]
pub enum Error {
    /// Generic HTTP errors produced using `http` crate.
    Http(http::Error),
    /// Websocket errors generated by `tungstenite` crate
    WebSocket(tungstenite::Error),
    /// REST client errors generated by `reqwest` crate
    Reqwest(reqwest::Error),
    /// Error that can be generated when building REST and Websocket client headers.
    InvalidHeaderValue(InvalidHeaderValue),
    /// Lavalink server error response because of a REST call.
    RestError(LavalinkErrorResponse),
    /// Error generated by `serde_json` when it was not possible to parse a response from the Lavalink server.
    InvalidResponse(serde_json::Error),
    /// Error generated by trying to use the REST API without a valid connection established by Websocket.
    NotConnected,
}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::Http(e) => e.fmt(f),
            Self::WebSocket(e) => e.fmt(f),
            Self::Reqwest(e) => e.fmt(f),
            Self::InvalidHeaderValue(e) => e.fmt(f),
            Self::InvalidResponse(e) => e.fmt(f),
            Self::RestError(e) => write!(f, "rest error: {}", e.message),
            Self::NotConnected => write!(f, "lavalink websocket hasn't connected"),
        }
    }
}
/// Just a `Result` with the error type set to `hydrolink::Error`.
pub type Result<T> = result::Result<T, Error>;

/// Configuration used by the Lavalink client to connect to the server.
pub struct LavalinkConfig {
    /// Lavalink server IP address.
    pub host: String,
    /// Lavalink server password.
    pub password: String,
    /// Enables the use of client-server TLS connections.
    pub tls: bool,
    /// Sets the maximum wait time for receiving the session ID.
    pub connection_timeout: u64,
    /// Sets the time between tries to resume the connection.
    pub resume_tries: u8,
    /// Sets the cooldown time between tries.
    pub resume_cooldown: u64,
}

impl LavalinkConfig {
    /// Initializes a new configuration with the required parameters.
    pub fn new(host: &str, password: &str) -> Self {
        Self {
            host: host.to_owned(),
            password: password.to_owned(),
            tls: false,
            connection_timeout: 5000,
            resume_tries: 3,
            resume_cooldown: 2000,
        }
    }

    /// Enables the use of TLS connections.
    pub fn enable_tls(&mut self) -> &mut Self {
        self.tls = true;
        self
    }

    /// Sets the maximum wait time for receiving the session ID.
    pub fn set_connection_timeout(&mut self, timeout: u64) -> &mut Self {
        self.connection_timeout = timeout;
        self
    }

    /// Sets the time between tries to resume the connection.
    pub fn set_resume_tries(&mut self, tries: u64) -> &mut Self {
        self.resume_tries = tries;
        self
    }

    /// Sets the cooldown time between tries.
    pub fn set_resume_cooldown(&mut self, cooldown: u64) -> &mut Self {
        self.resume_cooldown = cooldown;
        self
    }

    // Builds a URI that can be used to access the Lavalink server's Websocket using the parameters in this configuration.
    pub fn build_websocket_uri(&self) -> String {
        format!(
            "{}://{}/v3/websocket",
            match self.tls {
                true => "wss",
                false => "ws",
            },
            self.host
        )
    }

    /// Builds a URI that can be used to make REST calls to the Lavalink server.
    pub fn build_rest_uri(&self, api_call: &str) -> String {
        format!(
            "{}://{}/v3{}",
            match self.tls {
                true => "https",
                false => "http",
            },
            self.host,
            api_call,
        )
    }
}

/// Websocket connection status, this enum actually represents the usability and availability status of the session ID.
#[derive(Clone, PartialEq, Eq)]
pub enum ConnectionStatus {
    /// It means that the Websocket message parser has come to an end because the connection through the Websocket has been closed and the session ID cannot be used anymore.
    Disconnected,
    /// It means that the Websocket message parser is working but it is waiting for the Lavalink server to send the session ID.
    Connecting,
    /// It means that the Websocket message parser is working and the session ID is usable for REST calls.
    Connected,
}

/// Lavalink client used to send calls and receive messages from the Lavalink server.
#[derive(Clone)]
pub struct Lavalink {
    /// HTTP client with headers (authorization and user agent) predefined and ready to use.
    http_client: Client,
    /// Configuration used by this client to connect to the Lavalink server.
    config: Arc<LavalinkConfig>,
    /// Session ID of this connection, if the Websocket message parser received one.
    session_id: Arc<RwLock<String>>,
    /// Connection status of this Lavalink client.
    status: Arc<RwLock<ConnectionStatus>>,
    /// A write-only Websocket connection to the Lavalink server.
    connection: Arc<Mutex<WebSocketStream<MaybeTlsStream<TcpStream>>>>,
    /// Resume key that can be used to resume this connection.
    resume_key: Arc<Mutex<Option<String>>>,
}

impl Lavalink {
    /// Initializes the connection to the Lavalink server and this struct.
    pub async fn connect<H: Handler + Sync + Send + 'static>(
        config: LavalinkConfig,
        user_id: u64,
        handler: H,
    ) -> Result<Self> {
        let http_client = Client::builder()
            .default_headers({
                let mut headers = HeaderMap::new();
                headers.insert(
                    "Authorization",
                    config.password.parse().map_err(Error::InvalidHeaderValue)?,
                );
                headers
            })
            .user_agent("hydrolink/1.0.0")
            .build()
            .map_err(Error::Reqwest)?;

        let websocket_uri = config.build_websocket_uri();

        let request = Request::builder()
            .header("Host", websocket_uri.clone())
            .header("Connection", "Upgrade")
            .header("Upgrade", "websocket")
            .header("Sec-WebSocket-Version", "13")
            .header("Sec-WebSocket-Key", generate_key())
            .header("Authorization", config.password.clone())
            .header("User-Id", user_id)
            .header("Client-Name", "hydrolink/1.0.0")
            .uri(websocket_uri)
            .body(())
            .map_err(Error::Http)?;

        let (mut sink, stream) = connect_async(request)
            .await
            .or_else(|e| Err(Error::WebSocket(e)))?
            .0
            .split();

        let lavalink = Self {
            session_id: Arc::new(RwLock::new(String::new())),
            connection: Arc::new(Mutex::new(sink)),
            config: Arc::new(config),
            resume_key: Arc::new(Mutex::new(None)),
            status: Arc::new(RwLock::new(ConnectionStatus::Connecting)),
            http_client,
        };

        let (sender, mut receiver) = oneshot::channel();

        let lavalink_clone = lavalink.clone();
        spawn(async move {
            read_socket(handler, lavalink_clone, Some(sender), stream).await;
        });

        select! {
            _ = sleep(Duration::from_millis(LAVALINK_CONNECTION_TIMEOUT)) => {
                _ = sink.close().await;
                Err(LavalinkError::NotConnected)
            }
            msg = &mut receiver => {
                if let Err(_) = msg {
                    _ = sink.close().await;
                    return Err(LavalinkError::NotConnected);
                }

                Ok(lavalink)
            }
        }
    }

    pub fn connection_status(&self) -> ConnectionStatus {
        self.connection_status.read().clone()
    }

    pub async fn update_player(
        &self,
        guild_id: u64,
        no_replace: bool,
        player: &LavalinkUpdatePlayer,
    ) -> Result<LavalinkPlayer> {
        let response = self
            .http_client
            .patch(format!(
                "{}://{}/v3/sessions/{}/players/{}?noReplace={}",
                match self.tls {
                    true => "https",
                    false => "http",
                },
                self.host,
                self.session_id.read().await.clone(),
                guild_id,
                no_replace.to_string()
            ))
            .json(&player)
            .send()
            .await
            .map_err(|e| LavalinkError::Reqwest(e))?
            .bytes()
            .await
            .map_err(|e| LavalinkError::Reqwest(e))?;

        parse_response(&response)
    }

    pub async fn track_load(&self, identifier: &str) -> Result<LavalinkTrackLoading> {
        let response = self
            .http_client
            .get(format!(
                "{}://{}/v3/loadtracks?identifier={}",
                match self.tls {
                    true => "https",
                    false => "http",
                },
                self.host,
                identifier
            ))
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        parse_response(&response)
    }

    pub async fn get_player(&self, guild_id: u64) -> Result<LavalinkPlayer> {
        let response = self
            .http_client
            .get(format!(
                "{}://{}/v3/sessions/{}/players/{}",
                match self.tls {
                    true => "https",
                    false => "http",
                },
                self.host,
                self.session_id.read().await.clone(),
                guild_id
            ))
            .send()
            .await
            .map_err(|e| LavalinkError::Reqwest(e))?
            .bytes()
            .await
            .map_err(|e| LavalinkError::Reqwest(e))?;

        parse_response(&response)
    }

    pub async fn destroy_player(&self, guild_id: u64) -> Result<()> {
        self.http_client
            .delete(format!(
                "{}://{}/v3/sessions/{}/players/{}",
                match self.tls {
                    true => "https",
                    false => "http",
                },
                self.host,
                self.session_id.read().await.clone(),
                guild_id
            ))
            .send()
            .await
            .map_err(|e| LavalinkError::Reqwest(e))?
            .bytes()
            .await
            .map_err(|e| LavalinkError::Reqwest(e))?;

        Ok(())
    }

    pub async fn eq(&self, other: &Self) -> bool {
        self.session_id.read().await.clone() == other.session_id.read().await.clone()
            && self.host == other.host
            && self.connected.read().await.clone() == other.connected.read().await.clone()
    }
}

async fn read_socket<H: LavalinkHandler + Sync + Send + 'static>(
    handler: H,
    origin: Lavalink,
    mut sender: Option<oneshot::Sender<()>>,
    mut stream: SplitStream<
        WebSocketStream<Stream<TokioAdapter<TcpStream>, TokioAdapter<TlsStream<TcpStream>>>>,
    >,
) {
    while let Some(Ok(message)) = stream.next().await {
        if let Message::Text(message_str) = message {
            if let Ok(op) = serde_json::from_str::<LavalinkInternalOp>(&message_str) {
                match op.op {
                    LavalinkOpType::Ready => {
                        if let Ok(ready) = serde_json::from_str::<LavalinkReadyEvent>(&message_str)
                        {
                            origin
                                .session_id
                                .write()
                                .await
                                .replace_range(.., &ready.session_id);
                            *origin.connected.write().await = LavalinkConnection::Connected;

                            if let Some(some_sender) = sender {
                                if let Err(_) = some_sender.send(()) {
                                    break;
                                }

                                sender = None;
                            }

                            handler.lavalink_ready(origin.clone(), ready.resumed).await;
                        }
                    }
                    LavalinkOpType::Event => {
                        if let Ok(event) =
                            serde_json::from_str::<LavalinkInternalEvent>(&message_str)
                        {
                            match event.event_type {
                                LavalinkEventType::TrackStartEvent => {
                                    if let Ok(track_start) =
                                        serde_json::from_str::<LavalinkTrackStartEvent>(
                                            &message_str,
                                        )
                                    {
                                        handler
                                            .lavalink_track_start(origin.clone(), track_start)
                                            .await;
                                    }
                                }
                                LavalinkEventType::TrackEndEvent => {
                                    if let Ok(track_end) =
                                        serde_json::from_str::<LavalinkTrackEndEvent>(&message_str)
                                    {
                                        handler.lavalink_track_end(origin.clone(), track_end).await;
                                    }
                                }
                                _ => (),
                            }
                        }
                    }
                    _ => (),
                }
            }
        }
    }
    *origin.connected.write().await = LavalinkConnection::Disconnected;
    handler.lavalink_disconnect(origin).await;
}

fn generate_key() -> String {
    let r: [u8; 16] = rand::random();
    BASE64_STANDARD.encode(&r)
}

fn parse_response<'a, T: Deserialize<'a>>(response: &'a [u8]) -> Result<T> {
    serde_json::from_slice::<T>(&response).map_err(|_| {
        match serde_json::from_slice::<LavalinkErrorResponse>(&response) {
            Ok(v) => LavalinkError::RestError(v),
            Err(e) => LavalinkError::InvalidResponse(e),
        }
    })
}
