use std::{
    fmt::{self, Display, Formatter},
    result,
    sync::{Arc, Mutex, RwLock},
    time::Duration,
};

use async_trait::async_trait;
use base64::{prelude::BASE64_STANDARD, Engine};
use futures::{stream::SplitSink, SinkExt, StreamExt};
use reqwest::{
    header::{HeaderMap, InvalidHeaderValue, AUTHORIZATION},
    Client,
};
use tokio::{net::TcpStream, select, spawn, sync::oneshot, sync::Mutex as AsyncMutex, time::sleep};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{
        self,
        http::{self, Request},
        Message,
    },
    MaybeTlsStream, WebSocketStream,
};
use tracing::{debug, error, warn};

mod common;
mod filters;
mod internal;
mod parser;
mod rest;
mod websocket;

use parser::*;

pub use common::*;
pub use filters::*;
pub use rest::*;
pub use websocket::*;

pub const VERSION: &str = env!("CARGO_PKG_VERSION");

const CLIENT_NAME: &str = concat!("hydrolink/", env!("CARGO_PKG_VERSION"));

/// Event handler used by the Websocket message parser.
#[async_trait]
pub trait Handler {
    /// Triggered when the Websocket connection is established and a session ID for the REST client is received.
    async fn ready(&self, _lavalink: Session, _resumed: bool) {}
    /// Triggered when the Websocket disconnects from the Lavalink server, this event actually triggers as soon as the message parser loop is finished.
    async fn disconnect(&self, _lavalink: Session) {}
    /// Triggered every x seconds with the current state of the player.
    async fn player_update(&self, _lavalink: Session, _player_update: PlayerUpdate) {}
    /// Triggered every minute with stats from the Lavalink server.
    async fn stats(&self, _lavalink: Session, _stats: Stats) {}
    /// Event triggered when a new track is started.
    async fn track_start_event(&self, _lavalink: Session, _message: TrackStartEvent) {}
    /// Event triggered when a track ends.
    async fn track_end_event(&self, _lavalink: Session, _message: TrackEndEvent) {}
    /// Event triggered when an exception/error occurs while playing a track.
    async fn track_exception_event(&self, _lavalink: Session, _message: TrackExceptionEvent) {}
    /// Triggered when track is stuck.
    async fn track_stuck_event(&self, _lavalink: Session, _message: TrackStuckEvent) {}
    /// Triggered when the connection between the Lavalink server and Discord is closed, either for normal or abnormal reasons.
    async fn websocket_closed_event(&self, _lavalink: Session, _message: WebSocketClosedEvent) {}
}

/// Enum that groups all the errors that can occur.
#[derive(Debug)]
pub enum Error {
    /// Generic HTTP errors produced using `http` crate.
    Http(http::Error),
    /// Websocket errors generated by `tungstenite` crate
    WebSocket(tungstenite::Error),
    /// REST client errors generated by `reqwest` crate
    Reqwest(reqwest::Error),
    /// Error that can be generated when building REST and Websocket client headers.
    InvalidHeaderValue(InvalidHeaderValue),
    /// Lavalink server error response because of a REST call, and the parsing error, if the call has any response.
    RestError(ErrorResponse, Option<serde_json::Error>),
    /// Error generated by an attempt to parse the response of a request in the REST API, the first value is the error generated by `serde_json` in the attempt to parse the input in the proposed type, while the second is the error generated in the attempt to parse the input in an `ErrorResponse`.
    InvalidResponse(Option<serde_json::Error>, serde_json::Error),
    /// Error generated by trying to use the REST API without a valid connection established by Websocket.
    NotConnected,
    /// Error generated by trying to resume an already connected Lavalink session.
    AlreadyConnected,
}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::Http(e) => e.fmt(f),
            Self::WebSocket(e) => e.fmt(f),
            Self::Reqwest(e) => e.fmt(f),
            Self::InvalidHeaderValue(e) => e.fmt(f),
            Self::RestError(e1, _) => write!(f, "rest error: {}", e1.message),
            Self::NotConnected => write!(f, "lavalink websocket hasn't connected"),
            Self::AlreadyConnected => write!(f, "lavalink is already connected"),
            Self::InvalidResponse(e1, e2) => match e1 {
                Some(e) => e.fmt(f),
                None => e2.fmt(f),
            },
        }
    }
}
/// Just a `Result` with the error type set to `hydrolink::Error`.
pub type Result<T> = result::Result<T, Error>;

/// REST client used to access Lavalink API calls that are not dependent on a session or WebSocket connection.
#[derive(Clone)]
pub struct Lavalink {
    /// URL to be used as a base by the REST client.
    rest_url: Arc<String>,
    /// URL that will be used to start a new session with Lavalink.
    websocket_url: Arc<String>,
    /// Password used to login to the Lavalink server.
    password: Arc<String>,
    /// Reqwest HTTP client already configured with Lavalink password.
    http_client: Client,
    /// Is true if this REST client was created with encrypted URLs.
    tls: bool,
}

impl Lavalink {
    /// Initialize a new REST client using unencrypted URLs (such as http and ws) with Lavalink.
    pub fn new(host: &str, password: &str) -> Result<Self> {
        let rest_url = format!("http://{}", host);
        let websocket_url = format!("ws://{}/v3/websocket", host);

        let mut header_map = HeaderMap::new();
        header_map.insert(
            AUTHORIZATION,
            password.parse().map_err(Error::InvalidHeaderValue)?,
        );

        let http_client = Client::builder()
            .default_headers(header_map)
            .user_agent(CLIENT_NAME)
            .build()
            .map_err(Error::Reqwest)?;

        Ok(Self {
            rest_url: Arc::new(rest_url),
            websocket_url: Arc::new(websocket_url),
            password: Arc::new(password.to_owned()),
            tls: false,
            http_client,
        })
    }

    /// Initialize a new REST client using encrypted URLs (such as https and wss) with Lavalink.
    pub fn new_tls(host: &str, password: &str) -> Result<Self> {
        let rest_url = format!("https://{}", host);
        let websocket_url = format!("wss://{}/v3/websocket", host);

        let mut header_map = HeaderMap::new();
        header_map.insert(
            AUTHORIZATION,
            password.parse().map_err(Error::InvalidHeaderValue)?,
        );

        let http_client = Client::builder()
            .default_headers(header_map)
            .user_agent(CLIENT_NAME)
            .build()
            .map_err(Error::Reqwest)?;

        Ok(Self {
            rest_url: Arc::new(rest_url),
            websocket_url: Arc::new(websocket_url),
            password: Arc::new(password.to_owned()),
            tls: true,
            http_client,
        })
    }

    /// Checks if this REST client is using encrypted URLs.
    pub fn tls(&self) -> bool {
        self.tls
    }

    /// Initializes a `Session` and connects it to the Lavalink server.
    pub async fn connect<H: Handler + Sync + Send + 'static>(
        &self,
        user_id: u64,
        handler: H,
    ) -> Result<Session> {
        let session = Session::new(self.clone(), user_id, handler);
        session.connect().await?;
        Ok(session)
    }

    /// Resolves an identifier into a Track, or the search if there is a prefix in the identifier, such as `ytsearch:`, `ytmsearch:` or `scsearch:`.
    pub async fn track_load(&self, identifier: &str) -> Result<TrackLoading> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!("{}/v3/loadtracks?identifier={}", self.rest_url, identifier);

        #[cfg(feature = "lavalink-trace")]
        let path = format!(
            "{}/v3/loadtracks?identifier={}&trace=true",
            self.rest_url, identifier
        );

        let response = self
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [GET]: {}", path);

        parse_response(&response)
    }

    /// Decode a Base64 (encoded track) into a `Track`.
    pub async fn track_decode(&self, track: &str) -> Result<Track> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!("{}/v3/decodetrack?encodedTrack={}", self.rest_url, track);

        #[cfg(feature = "lavalink-trace")]
        let path = format!(
            "{}/v3/decodetrack?encodedTrack={}&trace=true",
            self.rest_url, track
        );

        let response = self
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [GET]: {}", path);

        parse_response(&response)
    }

    /// Get information from the Lavalink server.
    pub async fn info(&self) -> Result<Info> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!("{}/v3/info", self.rest_url);

        #[cfg(feature = "lavalink-trace")]
        let path = format!("{}/v3/info?trace=true", self.rest_url,);

        let response = self
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [GET]: {}", path);

        parse_response(&response)
    }

    /// Get statistics from Lavalink server using REST API.
    pub async fn stats(&self) -> Result<Stats> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!("{}/v3/stats", self.rest_url);

        #[cfg(feature = "lavalink-trace")]
        let path = format!("{}/v3/stats?trace=true", self.rest_url,);

        let response = self
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [GET]: {}", path);

        parse_response(&response)
    }

    /// Gets the version of the Lavalink server.
    pub async fn version(&self) -> Result<String> {
        let path = format!("{}/version", self.rest_url,);

        let response = self
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .text()
            .await
            .map_err(Error::Reqwest);

        debug!("REST [GET]: {}", path);

        response
    }

    /// Get the current status from the Route Planner.
    pub async fn routeplanner_status(&self) -> Result<RoutePlannerStatus> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!("{}/v3/routeplanner/status", self.rest_url);

        #[cfg(feature = "lavalink-trace")]
        let path = format!("{}/v3/routeplanner/status?trace=true", self.rest_url,);

        let response = self
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [GET]: {}", path);

        parse_response(&response)
    }

    /// Unmark an IP address as failed in the Route Planner.
    pub async fn routeplanner_unmark(&self, address: &str) -> Result<()> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!("{}/v3/routeplanner/free/address", self.rest_url);

        #[cfg(feature = "lavalink-trace")]
        let path = format!("{}/v3/routeplanner/free/address?trace=true", self.rest_url);

        let response = self
            .http_client
            .post(&path)
            .json(&RoutePlannerFailedAddress {
                address: address.to_owned(),
            })
            .send()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [POST]: {}", path);

        if !response.status().is_success() {
            return Err(
                serde_json::from_slice(&response.bytes().await.map_err(Error::Reqwest)?)
                    .map(|v| Error::RestError(v, None))
                    .map_err(|e| Error::InvalidResponse(None, e))?,
            );
        }

        Ok(())
    }

    /// Unmark all IP addresses as failed in the Route Planner.
    pub async fn routeplanner_unmark_all(&self) -> Result<()> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!("{}/v3/routeplanner/free/all", self.rest_url);

        #[cfg(feature = "lavalink-trace")]
        let path = format!("{}/v3/routeplanner/free/all?trace=true", self.rest_url);

        let response = self
            .http_client
            .post(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [POST]: {}", path);

        if !response.status().is_success() {
            return Err(
                serde_json::from_slice(&response.bytes().await.map_err(Error::Reqwest)?)
                    .map(|v| Error::RestError(v, None))
                    .map_err(|e| Error::InvalidResponse(None, e))?,
            );
        }

        Ok(())
    }
}

/// Possibly a connection to WebSocket (outbound only).
type WebSocketConnection =
    Arc<AsyncMutex<Option<SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>>>>;

/// Lavalink client used to send calls and receive messages from the Lavalink server.
#[derive(Clone)]
pub struct Session {
    /// Lavalink API REST client used by this session.
    rest: Lavalink,
    /// Session ID of this connection, if the Websocket message parser received one.
    session_id: Arc<RwLock<Option<String>>>,
    /// A outbound-only Websocket connection to the Lavalink server.
    connection: WebSocketConnection,
    /// Resume key that can be used to resume this connection.
    resume_key: Arc<Mutex<Option<String>>>,
    /// Event handler that will be used by the Websocket message parser.
    handler: Arc<Box<dyn Handler + Sync + Send>>,
    /// User ID used to connect to Websocket.
    user_id: u64,
}

impl Session {
    /// Create a new instance of this struct without connecting.
    #[inline]
    pub fn new<H: Handler + Sync + Send + 'static>(
        rest: Lavalink,
        user_id: u64,
        handler: H,
    ) -> Self {
        Self {
            handler: Arc::new(Box::new(handler)),
            resume_key: Arc::new(Mutex::new(None)),
            session_id: Arc::new(RwLock::new(None)),
            connection: Arc::new(AsyncMutex::new(None)),
            rest,
            user_id,
        }
    }

    /// Generates a new Request considering or not the resume_key.
    fn generate_websocket_request(&self, resume_key: Option<String>) -> Result<Request<()>> {
        Ok(match resume_key {
            Some(v) => Request::builder()
                .header("Host", self.rest.websocket_url.as_ref().clone())
                .header("Connection", "Upgrade")
                .header("Upgrade", "websocket")
                .header("Sec-WebSocket-Version", "13")
                .header("Sec-WebSocket-Key", generate_key())
                .header("Authorization", self.rest.password.as_ref().clone())
                .header("User-Id", self.user_id)
                .header("Client-Name", CLIENT_NAME)
                .header("Resume-Key", v)
                .uri(self.rest.websocket_url.as_ref().clone())
                .body(())
                .map_err(Error::Http)?,

            None => Request::builder()
                .header("Host", self.rest.websocket_url.as_ref().clone())
                .header("Connection", "Upgrade")
                .header("Upgrade", "websocket")
                .header("Sec-WebSocket-Version", "13")
                .header("Sec-WebSocket-Key", generate_key())
                .header("Authorization", self.rest.password.as_ref().clone())
                .header("User-Id", self.user_id)
                .header("Client-Name", CLIENT_NAME)
                .uri(self.rest.websocket_url.as_ref().clone())
                .body(())
                .map_err(Error::Http)?,
        })
    }

    /// Initializes the connection to the Lavalink server.
    pub async fn connect(&self) -> Result<()> {
        if self.session_id.read().unwrap().is_some() {
            return Err(Error::AlreadyConnected);
        }

        let request = self.generate_websocket_request(self.resume_key.lock().unwrap().clone())?;

        let (sink, stream) = connect_async(request)
            .await
            .map_err(Error::WebSocket)?
            .0
            .split();

        debug!(
            "WEBSOCKET [HANDSHAKE]: {}",
            self.rest.websocket_url.as_ref()
        );

        *self.connection.lock().await = Some(sink);

        let (sender, mut receiver) = oneshot::channel();

        let websocket_lavalink = self.clone();
        spawn(async move {
            websocket_message_parser(websocket_lavalink, Some(sender), stream).await;
        });

        select! {
            _ = sleep(Duration::from_millis(5_000)) => {
                warn!("WEBSOCKET [TIMEOUT]: {}", self.rest.websocket_url.as_ref());

                if let Err(e) = self.connection.lock().await.as_mut().unwrap().close().await {
                    error!("WEBSOCKET [ERROR]: {}", e);
                }

                Err(Error::NotConnected)
            }
            msg = &mut receiver => match msg {
                Ok(_) => Ok(()),
                Err(e) => {
                    warn!("WEBSOCKET [DROP]: {}", e);

                    if let Err(e) = self.connection.lock().await.as_mut().unwrap().close().await {
                        error!("WEBSOCKET [ERROR]: {}", e);
                    }

                    Err(Error::NotConnected)
                }
            }
        }
    }

    /// Disconnects from the Lavalink server.
    pub async fn disconnect(&self) -> Result<()> {
        self.connection
            .lock()
            .await
            .as_mut()
            .ok_or(Error::NotConnected)?
            .close()
            .await
            .map_err(Error::WebSocket)
    }

    /// Sets the resume key to be used on the next connection attempt.
    pub fn set_resume_key(&self, resume_key: Option<String>) {
        *self.resume_key.lock().unwrap() = resume_key;
    }

    /// Generate and set a new resume key on the Lavalink server.
    pub async fn configure_resume(&self, timeout: Option<u32>) -> Result<String> {
        let key = generate_key();
        self.update_session(UpdateSession {
            resuming_key: Some(Some(key.clone())),
            timeout,
        })
        .await?;
        self.set_resume_key(Some(key.clone()));
        Ok(key)
    }

    /// Check if the Websocket is connected.
    #[inline]
    pub fn is_connected(&self) -> bool {
        self.session_id.read().unwrap().is_some()
    }

    /// Check if the connection is resumable.
    #[inline]
    pub fn is_resumable(&self) -> bool {
        self.resume_key.lock().unwrap().is_some()
    }

    /// Gets a clone of the REST Client used in this `Session`.
    #[inline]
    pub fn rest(&self) -> Lavalink {
        self.rest.clone()
    }

    /// Resolves an identifier into a Track, or the search if there is a prefix in the identifier, such as `ytsearch:`, `ytmsearch:` or `scsearch:`.
    #[inline]
    pub async fn track_load(&self, identifier: &str) -> Result<TrackLoading> {
        self.rest.track_load(identifier).await
    }

    /// Decode a Base64 (encoded track) into a `Track`.
    #[inline]
    pub async fn track_decode(&self, track: &str) -> Result<Track> {
        self.rest.track_decode(track).await
    }

    /// Get information from the Lavalink server.
    #[inline]
    pub async fn info(&self) -> Result<Info> {
        self.rest.info().await
    }

    /// Get statistics from Lavalink server using REST API.
    #[inline]
    pub async fn stats(&self) -> Result<Stats> {
        self.rest.stats().await
    }

    /// Gets the version of the Lavalink server.
    #[inline]
    pub async fn version(&self) -> Result<String> {
        self.rest.version().await
    }

    /// Get the current status from the Route Planner.
    #[inline]
    pub async fn routeplanner_status(&self) -> Result<RoutePlannerStatus> {
        self.rest.routeplanner_status().await
    }

    /// Unmark an IP address as failed in the Route Planner.
    #[inline]
    pub async fn routeplanner_unmark(&self, address: &str) -> Result<()> {
        self.rest.routeplanner_unmark(address).await
    }

    /// Unmark all IP addresses as failed in the Route Planner.
    #[inline]
    pub async fn routeplanner_unmark_all(&self) -> Result<()> {
        self.rest.routeplanner_unmark_all().await
    }

    /// Updates or creates the player for this guild if it doesn't already exist.
    pub async fn update_player(
        &self,
        guild_id: u64,
        no_replace: bool,
        player: UpdatePlayer,
    ) -> Result<Player> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!(
            "{}/v3/sessions/{}/players/{}?noReplace={}",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
            guild_id,
            no_replace
        );

        #[cfg(feature = "lavalink-trace")]
        let path = format!(
            "{}/v3/sessions/{}/players/{}?noReplace={}&trace=true",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
            guild_id,
            no_replace
        );

        let response = self
            .rest
            .http_client
            .patch(&path)
            .json(&player)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [PATCH]: {}", path);

        parse_response(&response)
    }

    /// Returns the player for this guild in this session.
    pub async fn get_player(&self, guild_id: u64) -> Result<Player> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!(
            "{}/v3/sessions/{}/players/{}",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
            guild_id
        );

        #[cfg(feature = "lavalink-trace")]
        let path = format!(
            "{}/v3/sessions/{}/players/{}?trace=true",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
            guild_id
        );

        let response = self
            .rest
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [GET]: {}", path);

        parse_response(&response)
    }

    /// Returns all players in this session.
    pub async fn get_players(&self) -> Result<Vec<Player>> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!(
            "{}/v3/sessions/{}/players",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
        );

        #[cfg(feature = "lavalink-trace")]
        let path = format!(
            "{}/v3/sessions/{}/players?trace=true",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
        );

        let response = self
            .rest
            .http_client
            .get(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [GET]: {}", path);

        parse_response(&response)
    }

    /// Destroys the player for this guild in this session.
    pub async fn destroy_player(&self, guild_id: u64) -> Result<()> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!(
            "{}/v3/sessions/{}/players/{}",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
            guild_id
        );

        #[cfg(feature = "lavalink-trace")]
        let path = format!(
            "{}/v3/sessions/{}/players/{}?trace=true",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
            guild_id
        );

        let response = self
            .rest
            .http_client
            .delete(&path)
            .send()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [DELETE]: {}", path);

        if !response.status().is_success() {
            return Err(
                serde_json::from_slice(&response.bytes().await.map_err(Error::Reqwest)?)
                    .map(|v| Error::RestError(v, None))
                    .map_err(|e| Error::InvalidResponse(None, e))?,
            );
        }

        Ok(())
    }

    /// Updates the Lavalink session by setting a timeout and a resume key.
    pub async fn update_session(&self, update_session: UpdateSession) -> Result<UpdateSession> {
        #[cfg(not(feature = "lavalink-trace"))]
        let path = format!(
            "{}/v3/sessions/{}",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
        );

        #[cfg(feature = "lavalink-trace")]
        let path = format!(
            "{}/v3/sessions/{}?trace=true",
            self.rest.rest_url.as_ref().clone(),
            self.session_id
                .read()
                .unwrap()
                .clone()
                .ok_or(Error::NotConnected)?,
        );

        let response = self
            .rest
            .http_client
            .patch(&path)
            .json(&update_session)
            .send()
            .await
            .map_err(Error::Reqwest)?
            .bytes()
            .await
            .map_err(Error::Reqwest)?;

        debug!("REST [PATCH]: {}", path);

        parse_response(&response)
    }
}

/// Generates a new random key from 16 Base64 encoded bytes.
fn generate_key() -> String {
    let r: [u8; 16] = rand::random();
    BASE64_STANDARD.encode(r)
}
